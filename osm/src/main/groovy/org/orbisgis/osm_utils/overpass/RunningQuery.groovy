/*
 * Bundle OSM is part of the OrbisGIS platform
 *
 * OrbisGIS is a java GIS application dedicated to research in GIScience.
 * OrbisGIS is developed by the GIS group of the DECIDE team of the
 * Lab-STICC CNRS laboratory, see <http://www.lab-sticc.fr/>.
 *
 * The GIS group of the DECIDE team is located at :
 *
 * Laboratoire Lab-STICC – CNRS UMR 6285
 * Equipe DECIDE
 * UNIVERSITÉ DE BRETAGNE-SUD
 * Institut Universitaire de Technologie de Vannes
 * 8, Rue Montaigne - BP 561 56017 Vannes Cedex
 *
 * OSM is distributed under LGPL 3 license.
 *
 * Copyright (C) 2019 CNRS (Lab-STICC UMR CNRS 6285)
 *
 *
 * OSM is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OSM is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with
 * OSM. If not, see <http://www.gnu.org/licenses/>.
 *
 * For more information, please consult: <http://www.orbisgis.org/>
 * or contact directly:
 * info_at_ orbisgis.org
 */
package org.orbisgis.osm_utils.overpass

import java.text.SimpleDateFormat
import java.time.ZoneId

/**
 * Running query on the Overpass server.
 */
class RunningQuery {

    /** PID of the running query. */
    def pid
    /** Memory space limit for the data generated by the query. */
    def spaceLimit
    /** Timeout for the query execution. */
    def timeLimit
    /** {@linkl Data} when the query execution has started. */
    def startTime

    /** {@link java.text.SimpleDateFormat} used to parse dates. */
    private format = "yyyy-MM-dd'T'HH:mm:ss'Z'" as SimpleDateFormat
    private local = "yyyy-MM-dd'T'HH:mm:ss'Z'" as SimpleDateFormat

    /**
     * Main constructor.
     * @param text {@link java.lang.String} representation of the query.
     */
    RunningQuery(String text){
        format.setTimeZone(TimeZone.getTimeZone("Etc/GMT+0"))
        local.setTimeZone(TimeZone.getTimeZone(ZoneId.systemDefault()))
        def array = text.split()
        pid = Integer.decode(array[0])
        spaceLimit = Integer.decode(array[1])
        timeLimit = Integer.decode(array[2])
        startTime = format.parse(array[3])
    }

    /**
     * Get the number of second to wait for the query timeout since the given {@link java.util.Date}.
     * @param current {@link java.util.Date} use as reference.
     * @return Number of seconds to wait .
     */
    long getWaitSeconds(Date current){
        return timeLimit - startTime.toInstant().secondsUntil(current.toInstant())
    }

    /**
     * Get the number of second to wait for the query timeout since the current {@link java.util.Date}.
     * @return Number of seconds to wait.
     */
    long getWaitSeconds(){
        return getWaitSeconds(new Date())
    }

    @Override
    String toString(){
        return "$pid\t$spaceLimit\t$timeLimit\t${local.format(startTime)}"
    }
}
